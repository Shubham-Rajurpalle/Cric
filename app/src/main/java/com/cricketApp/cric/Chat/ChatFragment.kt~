package com.cricketApp.cric.Chat

import android.app.AlertDialog
import android.os.Bundle
import android.util.Log
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.EditText
import android.widget.LinearLayout
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.widget.addTextChangedListener
import androidx.fragment.app.replace
import androidx.recyclerview.widget.LinearLayoutManager
import com.bumptech.glide.Glide
import com.cricketApp.cric.Leaderboard.LeaderboardFragment
import com.cricketApp.cric.Profile.ProfileFragment
import com.cricketApp.cric.R
import com.cricketApp.cric.databinding.FragmentChatBinding
import com.google.android.material.bottomnavigation.BottomNavigationMenuView
import com.google.android.material.bottomnavigation.BottomNavigationView
import com.google.android.material.chip.Chip
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ValueEventListener
import org.checkerframework.common.subtyping.qual.Bottom
import kotlin.math.log

class ChatFragment : Fragment() {

    private lateinit var binding: FragmentChatBinding
    private lateinit var adapter: ChatAdapter
    private lateinit var messages: ArrayList<Any> // Can hold both ChatMessage and PollMessage
    private lateinit var database: FirebaseDatabase
    private val currentUser = FirebaseAuth.getInstance().currentUser
    private var userTeam: String = "CSK" // Default team, will be updated from user profile

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        binding = FragmentChatBinding.inflate(inflater, container, false)
        ViewCompat.setOnApplyWindowInsetsListener(binding.root) { view, insets ->
            val imeVisible = insets.isVisible(WindowInsetsCompat.Type.ime()) // Check if IME is visible
            val height=requireActivity().findViewById<BottomNavigationView>(R.id.bottomNavigation).height
            val bottomInsets = if (imeVisible) {
                insets.getInsets(WindowInsetsCompat.Type.ime()).bottom-height // Use IME insets when keyboard is visible
            } else {
                insets.getInsets(WindowInsetsCompat.Type.systemBars()).bottom// Use system bar insets otherwise
            }

            view.setPadding(0,0 , 0, bottomInsets)

            insets
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Initialize Firebase
        database = FirebaseDatabase.getInstance()

        loadProfilePhoto()

        // Fetch user's team
        fetchUserTeam()

        // Setup RecyclerView
        messages = ArrayList()
        adapter = ChatAdapter(messages)
        binding.recyclerViewMessages.apply {
            layoutManager = LinearLayoutManager(context,LinearLayoutManager.VERTICAL,true)
            (layoutManager as LinearLayoutManager).stackFromEnd = true
            adapter = this@ChatFragment.adapter
        }

        // Setup filters
        setupFilters()

        // Load messages from Firebase
        loadMessages()

        // Setup send button
        binding.buttonSend.setOnClickListener {
            sendMessage()
        }

        // Setup poll button
        binding.buttonPoll.setOnClickListener {
            showCreatePollDialog()
        }

        binding.leaderBoardIcon.setOnClickListener {

            val bottomNavigation:BottomNavigationView=requireActivity().findViewById(R.id.bottomNavigation)
            bottomNavigation.selectedItemId=R.id.leaderboardIcon
            val fragmentManager=parentFragmentManager
            val transaction=fragmentManager.beginTransaction()
            transaction.replace(R.id.navHost,LeaderboardFragment())
            transaction.addToBackStack(null)
            transaction.commit()

        }

        binding.profilePhoto.setOnClickListener {
            val bottomNavigation:BottomNavigationView=requireActivity().findViewById(R.id.bottomNavigation)
            bottomNavigation.selectedItemId=R.id.profileIcon
            val fragmentManager=parentFragmentManager
            val transaction=fragmentManager.beginTransaction()
            transaction.replace(R.id.navHost,ProfileFragment())
            transaction.addToBackStack(null)
            transaction.commit()
        }

    }

    private fun loadProfilePhoto(){
        val userId=currentUser?.uid?:return
        val userRef = database.getReference("Users/$userId/profilePhoto")
        userRef.addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val photoUrl=snapshot.getValue(String::class.java)
                if (!photoUrl.isNullOrEmpty()) {
                    Glide.with(context ?: return)
                        .load(photoUrl)
                        .placeholder(R.drawable.profile_icon)
                        .into(binding.profilePhoto)
                } else {
                    Log.e("Profile", "No profile photo found")
                }
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e("ChatFragment", "Error loading profile photo", error.toException())
            }
        })
    }

    private fun fetchUserTeam() {
        currentUser?.uid?.let { userId ->
            val userRef = database.getReference("Users/$userId/iplTeam")
            userRef.addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) {
                    userTeam = snapshot.getValue(String::class.java) ?: "No Team"
                }

                override fun onCancelled(error: DatabaseError) {
                    // Keep default team
                }
            })
        }
    }

    private var selectedFilter = mutableSetOf<String>()

    private fun setupFilters() {
        binding.chipAll.setOnClickListener { resetFilters() }
        binding.chipTopHits.setOnClickListener { toggleFilter("TopHits") { loadTopHitMessages() } }
        binding.chipTopMiss.setOnClickListener { toggleFilter("TopMiss") { loadTopMissMessages() } }
        binding.chipPolls.setOnClickListener { toggleFilter("Polls") { loadPollsOnly() } }
        binding.chipCSK.setOnClickListener { toggleFilter("CSK") { loadTeamMessages("CSK") } }
        binding.chipMI.setOnClickListener { toggleFilter("MI") { loadTeamMessages("MI") } }
        binding.chipDC.setOnClickListener { toggleFilter("DC") { loadTeamMessages("DC") } }
        binding.chipGT.setOnClickListener { toggleFilter("GT") { loadTeamMessages("GT") } }
        binding.chipKKR.setOnClickListener { toggleFilter("KKR") { loadTeamMessages("KKR") } }
        binding.chipLSG.setOnClickListener { toggleFilter("LSG") { loadTeamMessages("LSG") } }
        binding.chipRCB.setOnClickListener { toggleFilter("RCB") { loadTeamMessages("RCB") } }
        binding.chipPBKS.setOnClickListener { toggleFilter("PBKS") { loadTeamMessages("PBKS") } }
        binding.chipRR.setOnClickListener { toggleFilter("RR") { loadTeamMessages("RR") } }
        binding.chipSRH.setOnClickListener { toggleFilter("SRH") { loadTeamMessages("SRH") } }

        binding.chipAll.isChecked = true
    }

    private fun toggleFilter(filter: String, action: () -> Unit) {
        val chip = when (filter) {
            "TopHits" -> binding.chipTopHits
            "TopMiss" -> binding.chipTopMiss
            "Polls" -> binding.chipPolls
            "CSK" -> binding.chipCSK
            "MI" -> binding.chipMI
            "DC" -> binding.chipDC
            "GT" -> binding.chipGT
            "KKR" -> binding.chipKKR
            "LSG" -> binding.chipLSG
            "RCB" -> binding.chipRCB
            "PBKS" -> binding.chipPBKS
            "RR" -> binding.chipRR
            "SRH" -> binding.chipSRH
            else -> null
        }

        val isSelected = selectedFilter.contains(filter)

        if (isSelected) {
            selectedFilter.remove(filter)
            chip?.isChecked = false
            chip?.isSelected = false
            chip?.chipStrokeWidth = 0f
        } else {
            selectedFilter.add(filter)
            chip?.isChecked = true
            chip?.isSelected = true
            chip?.chipStrokeWidth = 4f
        }

        applyFilters()
    }

    private fun applyFilters(){
        if (selectedFilter.isEmpty()){
            loadMessages()
            return
        }
        if (selectedFilter.contains("TopHits")){ loadTopHitMessages() }
        if (selectedFilter.contains("TopMiss")){loadTopMissMessages() }
        if (selectedFilter.contains("Polls")){loadPollsOnly() }

        val selectedTeams=selectedFilter.filter { it !in listOf("TopHits", "TopMiss", "Polls") }
        if(selectedTeams.isNotEmpty()){
            selectedTeams.forEach{ team ->loadTeamMessages(team) }
        }
    }

    private fun resetFilters() {
        selectedFilter.clear()

        binding.chipAll.isChecked = true

        val allChips = listOf(
            binding.chipTopHits, binding.chipTopMiss, binding.chipPolls,
            binding.chipCSK, binding.chipMI, binding.chipDC, binding.chipGT,
            binding.chipKKR, binding.chipLSG, binding.chipRCB, binding.chipPBKS,
            binding.chipRR, binding.chipSRH
        )

        allChips.forEach { chip ->
            chip.isChecked = false
            chip.isSelected = false
            chip.chipStrokeWidth = 0f
        }

        loadMessages()
    }

    private fun loadMessages() {
        val chatsRef = database.getReference("NoBallZone/chats")

        messages.clear()

        // Load chat messages
        chatsRef.addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val tempMessages = ArrayList<Any>()

                for (chatSnapshot in snapshot.children) {
                    val chat = chatSnapshot.getValue(ChatMessage::class.java)
                    chat?.let {
                        it.id = chatSnapshot.key ?: ""
                        tempMessages.add(it)
                    }
                }

                // Add to main list and sort later
                messages.clear()
                messages.addAll(tempMessages)

                // Load poll messages (need to be in same listener to ensure proper sorting)
                loadPollMessages()
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }

    private fun loadPollMessages() {
        val pollsRef = database.getReference("NoBallZone/polls")

        pollsRef.addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val tempPolls = ArrayList<Any>()

                for (pollSnapshot in snapshot.children) {
                    val poll = pollSnapshot.getValue(PollMessage::class.java)
                    poll?.let {
                        it.id = pollSnapshot.key ?: ""
                        tempPolls.add(it)
                    }
                }

                // Add to main list
                messages.addAll(tempPolls)

                // Sort all messages by timestamp
                messages.sortByDescending {
                    when (it) {
                        is ChatMessage -> it.timestamp
                        is PollMessage -> it.timestamp
                        else -> 0L
                    }
                }

                adapter.notifyDataSetChanged()

                // Scroll to top after loading
                if (messages.isNotEmpty()) {
                    binding.recyclerViewMessages.scrollToPosition(0)
                }
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }

    private fun loadTopHitMessages() {
        val chatsRef = database.getReference("NoBallZone/chats")
        messages.clear()

        // Load chat messages with high hits (only messages with hits > 0)
        chatsRef.orderByChild("hit").startAt(1.0).addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val tempMessages = ArrayList<Any>()

                for (chatSnapshot in snapshot.children) {
                    val chat = chatSnapshot.getValue(ChatMessage::class.java)
                    chat?.let {
                        it.id = chatSnapshot.key ?: ""
                        tempMessages.add(it)
                    }
                }

                // Add to main list
                messages.clear()
                messages.addAll(tempMessages)

                // Load poll messages with high hits
                loadTopHitPolls()
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }


    private fun loadTopHitPolls() {
        val pollsRef = database.getReference("NoBallZone/polls")

        pollsRef.orderByChild("hit").startAt(1.0).addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val tempPolls = ArrayList<Any>()

                for (pollSnapshot in snapshot.children) {
                    val poll = pollSnapshot.getValue(PollMessage::class.java)
                    poll?.let {
                        it.id = pollSnapshot.key ?: ""
                        tempPolls.add(it)
                    }
                }

                // Add to main list
                messages.addAll(tempPolls)

                // Sort all messages by hit count (descending) and then by timestamp
                messages.sortWith(compareByDescending<Any> {
                    when (it) {
                        is ChatMessage -> it.hit ?: 0
                        is PollMessage -> it.hit ?: 0
                        else -> 0
                    }
                }.thenByDescending {
                    when (it) {
                        is ChatMessage -> it.timestamp
                        is PollMessage -> it.timestamp
                        else -> 0L
                    }
                })

                adapter.notifyDataSetChanged()
                if (messages.isNotEmpty()) {
                    binding.recyclerViewMessages.scrollToPosition(0)
                }
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }
    private fun loadTopMissMessages() {
        val chatsRef = database.getReference("NoBallZone/chats")
        messages.clear()

        // Load chat messages with high misses (only messages with misses > 0)
        chatsRef.orderByChild("miss").startAt(1.0).addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val tempMessages = ArrayList<Any>()

                for (chatSnapshot in snapshot.children) {
                    val chat = chatSnapshot.getValue(ChatMessage::class.java)
                    chat?.let {
                        it.id = chatSnapshot.key ?: ""
                        tempMessages.add(it)
                    }
                }

                // Add to main list
                messages.clear()
                messages.addAll(tempMessages)

                // Load poll messages with high misses
                loadTopMissPolls()
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }


    private fun loadTopMissPolls() {
        val pollsRef = database.getReference("NoBallZone/polls")

        pollsRef.orderByChild("miss").startAt(1.0).addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val tempPolls = ArrayList<Any>()

                for (pollSnapshot in snapshot.children) {
                    val poll = pollSnapshot.getValue(PollMessage::class.java)
                    poll?.let {
                        it.id = pollSnapshot.key ?: ""
                        tempPolls.add(it)
                    }
                }

                // Add to main list
                messages.addAll(tempPolls)

                // Sort all messages by miss count (descending) and then by timestamp
                messages.sortWith(compareByDescending<Any> {
                    when (it) {
                        is ChatMessage -> it.miss ?: 0
                        is PollMessage -> it.miss ?: 0
                        else -> 0
                    }
                }.thenByDescending {
                    when (it) {
                        is ChatMessage -> it.timestamp
                        is PollMessage -> it.timestamp
                        else -> 0L
                    }
                })

                adapter.notifyDataSetChanged()
                if (messages.isNotEmpty()) {
                    binding.recyclerViewMessages.scrollToPosition(0)
                }
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }

    private fun loadPollsOnly() {
        val pollsRef = database.getReference("NoBallZone/polls")

        messages.clear()

        pollsRef.addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                messages.clear()

                for (pollSnapshot in snapshot.children) {
                    val poll = pollSnapshot.getValue(PollMessage::class.java)
                    poll?.let {
                        it.id = pollSnapshot.key ?: ""
                        messages.add(it)
                    }
                }

                // Sort polls by timestamp
                messages.sortByDescending {
                    when (it) {
                        is PollMessage -> it.timestamp
                        else -> 0L
                    }
                }

                adapter.notifyDataSetChanged()

                // Scroll to top after loading
                if (messages.isNotEmpty()) {
                    binding.recyclerViewMessages.scrollToPosition(0)
                }
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }

    private fun loadTeamMessages(team: String) {
        val chatsRef = database.getReference("NoBallZone/chats")

        messages.clear()

        // Load team chat messages
        chatsRef.orderByChild("team").equalTo(team).addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val tempMessages = ArrayList<Any>()

                for (chatSnapshot in snapshot.children) {
                    val chat = chatSnapshot.getValue(ChatMessage::class.java)
                    chat?.let {
                        it.id = chatSnapshot.key ?: ""
                        tempMessages.add(it)
                    }
                }

                // Add to main list
                messages.clear()
                messages.addAll(tempMessages)

                // Load team poll messages
                loadTeamPolls(team)
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }

    private fun loadTeamPolls(team: String) {
        val pollsRef = database.getReference("NoBallZone/polls")

        pollsRef.orderByChild("team").equalTo(team).addValueEventListener(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val tempPolls = ArrayList<Any>()

                for (pollSnapshot in snapshot.children) {
                    val poll = pollSnapshot.getValue(PollMessage::class.java)
                    poll?.let {
                        it.id = pollSnapshot.key ?: ""
                        tempPolls.add(it)
                    }
                }

                // Add to main list
                messages.addAll(tempPolls)

                // Sort all messages by timestamp
                messages.sortByDescending {
                    when (it) {
                        is ChatMessage -> it.timestamp
                        is PollMessage -> it.timestamp
                        else -> 0L
                    }
                }

                adapter.notifyDataSetChanged()

                // Scroll to top after loading
                if (messages.isNotEmpty()) {
                    binding.recyclerViewMessages.scrollToPosition(0)
                }
            }

            override fun onCancelled(error: DatabaseError) {
                // Handle error
            }
        })
    }

    private fun sendMessage() {
        val messageText = binding.editTextMessage.text.toString().trim()
        if (messageText.isEmpty()) return

        if (currentUser == null) {
            // Handle not logged in
            return
        }

        val chatRef = database.getReference("NoBallZone/chats").push()
        val chatId = chatRef.key ?: return

        // Get user's display name and profile picture
        val userRef = database.getReference("Users/${currentUser.uid}")
        userRef.addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val userName = snapshot.child("username").getValue(String::class.java) ?: currentUser.displayName ?: "Anonymous"

                val chatMessage = ChatMessage(
                    id = chatId,
                    senderId = currentUser.uid,
                    senderName = userName,
                    team = userTeam,
                    message = messageText,
                    timestamp = System.currentTimeMillis()
                )

                chatRef.setValue(chatMessage)
                    .addOnSuccessListener {
                        binding.editTextMessage.text.clear()
                    }
                    .addOnFailureListener {
                        // Handle error
                    }
            }

            override fun onCancelled(error: DatabaseError) {
                // Fallback to default user info
                val chatMessage = ChatMessage(
                    id = chatId,
                    senderId = currentUser.uid,
                    senderName = currentUser.displayName ?: "Anonymous",
                    team = userTeam,
                    message = messageText,
                    timestamp = System.currentTimeMillis()
                )

                chatRef.setValue(chatMessage)
                    .addOnSuccessListener {
                        binding.editTextMessage.text.clear()
                    }
                    .addOnFailureListener {
                        // Handle error
                    }
            }
        })
    }

    private fun showCreatePollDialog() {
        if (currentUser == null) {
            // Handle not logged in
            return
        }

        val dialogView = LayoutInflater.from(context).inflate(R.layout.poll_create_dialog, null)
        val editTextQuestion = dialogView.findViewById<EditText>(R.id.editTextPollQuestion)
        val layoutOptions = dialogView.findViewById<LinearLayout>(R.id.layoutAdditionalOptions)
        val buttonAddOption = dialogView.findViewById<Button>(R.id.buttonAddOption)

        // Set up the initial two options
        val optionLayouts = ArrayList<View>()
        val addOption = {
            val optionView = LayoutInflater.from(context).inflate(R.layout.item_poll_option, null)
            layoutOptions.addView(optionView)
            optionLayouts.add(optionView)
        }

        // Add initial two options
        addOption()
        addOption()

        // Add option button
        buttonAddOption.setOnClickListener {
            if (optionLayouts.size < 5) { // Limit to 6 options
                addOption()
            }
        }

        // Create and show dialog
        val dialog = AlertDialog.Builder(context)
            .setTitle("Create Poll")
            .setView(dialogView)
            .setPositiveButton("Create") { _, _ ->
                createPoll(editTextQuestion.text.toString(), optionLayouts)
            }
            .setNegativeButton("Cancel", null)
            .create()

        dialog.show()
    }

    private fun createPoll(question: String, optionViews: List<View>) {
        if (question.trim().isEmpty() || currentUser == null) return

        val options = mutableMapOf<String, Int>()

        // Collect options
        for (optionView in optionViews) {
            val editTextOption = optionView.findViewById<EditText>(R.id.editTextOption1)
            val optionText = editTextOption.text.toString().trim()

            if (optionText.isNotEmpty()) {
                options[optionText] = 0
            }
        }

        // Need at least two options
        if (options.size < 2) return

        val pollRef = database.getReference("NoBallZone/polls").push()
        val pollId = pollRef.key ?: return

        // Get user's display name and team
        val userRef = database.getReference("Users/${currentUser.uid}")
        userRef.addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val userName = snapshot.child("displayName").getValue(String::class.java) ?: currentUser.displayName ?: "Anonymous"

                val pollMessage = PollMessage(
                    id = pollId,
                    senderId = currentUser.uid,
                    senderName = userName,
                    team = userTeam,
                    question = question,
                    options = options.toMutableMap(),
                    timestamp = System.currentTimeMillis()
                )

                pollRef.setValue(pollMessage)
                    .addOnFailureListener {
                        // Handle error
                    }
            }

            override fun onCancelled(error: DatabaseError) {
                // Fallback to default user info
                val pollMessage = PollMessage(
                    id = pollId,
                    senderId = currentUser.uid,
                    senderName = currentUser.displayName ?: "Anonymous",
                    team = userTeam,
                    question = question,
                    options = options.toMutableMap(),
                    timestamp = System.currentTimeMillis()
                )

                pollRef.setValue(pollMessage)
                    .addOnFailureListener {
                        // Handle error
                    }
            }
        })
    }
}