package com.cricketApp.cric.Chat

import android.animation.ObjectAnimator
import android.content.Context
import android.content.Intent
import android.graphics.Typeface
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.animation.DecelerateInterpolator
import android.widget.ImageView
import android.widget.ProgressBar
import android.widget.RadioButton
import android.widget.TextView
import android.widget.Toast
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.cricketApp.cric.R
import com.cricketApp.cric.databinding.ItemPollMessageBinding
import com.cricketApp.cric.databinding.ItemReceiveChatBinding
import com.cricketApp.cric.databinding.ItemSendChatBinding
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.MutableData
import com.google.firebase.database.Transaction
import com.google.firebase.database.ValueEventListener

class ChatAdapter(private val items: List<Any>) :
    RecyclerView.Adapter<RecyclerView.ViewHolder>() {

    companion object {
        private const val VIEW_TYPE_SEND_CHAT = 1
        private const val VIEW_TYPE_RECEIVE_CHAT = 2
        private const val VIEW_TYPE_POLL = 3

        // Payload constants
        private const val PAYLOAD_REACTION = "reaction"
        private const val PAYLOAD_HIT_MISS = "hit_miss"
        private const val PAYLOAD_COMMENTS = "comments"
    }

    override fun getItemViewType(position: Int): Int {
        return when (items[position]) {
            is ChatMessage -> if ((items[position] as ChatMessage).senderId == FirebaseAuth.getInstance().currentUser?.uid) VIEW_TYPE_SEND_CHAT else VIEW_TYPE_RECEIVE_CHAT
            is PollMessage -> VIEW_TYPE_POLL
            else -> throw IllegalArgumentException("Unknown view type")
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        val inflater = LayoutInflater.from(parent.context)
        return when (viewType) {
            VIEW_TYPE_SEND_CHAT -> {
                val binding = ItemSendChatBinding.inflate(inflater, parent, false)
                ChatSendViewHolder(binding)
            }
            VIEW_TYPE_RECEIVE_CHAT -> {
                val binding = ItemReceiveChatBinding.inflate(inflater, parent, false)
                ChatReceiveViewHolder(binding)
            }
            VIEW_TYPE_POLL -> {
                val binding = ItemPollMessageBinding.inflate(inflater, parent, false)
                PollViewHolder(binding)
            }
            else -> throw IllegalArgumentException("Invalid view type")
        }
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        when (holder) {
            is ChatSendViewHolder -> holder.bind(items[position] as ChatMessage)
            is ChatReceiveViewHolder -> holder.bind(items[position] as ChatMessage)
            is PollViewHolder -> holder.bind(items[position] as PollMessage)
        }
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int, payloads: List<Any>) {
        if (payloads.isEmpty()) {
            // No payload, do full bind
            onBindViewHolder(holder, position)
            return
        }

        // Handle partial updates
        for (payload in payloads) {
            if (payload is String) {
                when (payload) {
                    PAYLOAD_REACTION -> {
                        when (holder) {
                            is ChatSendViewHolder -> holder.updateReactions(items[position] as ChatMessage)
                            is ChatReceiveViewHolder -> holder.updateReactions(items[position] as ChatMessage)
                            is PollViewHolder -> holder.updateReactions(items[position] as PollMessage)
                        }
                    }
                    PAYLOAD_HIT_MISS -> {
                        when (holder) {
                            is ChatSendViewHolder -> holder.updateHitMiss(items[position] as ChatMessage)
                            is ChatReceiveViewHolder -> holder.updateHitMiss(items[position] as ChatMessage)
                            is PollViewHolder -> holder.updateHitMiss(items[position] as PollMessage)
                        }
                    }
                    PAYLOAD_COMMENTS -> {
                        when (holder) {
                            is ChatSendViewHolder -> holder.updateComments(items[position] as ChatMessage)
                            is ChatReceiveViewHolder -> holder.updateComments(items[position] as ChatMessage)
                            is PollViewHolder -> holder.updateComments(items[position] as PollMessage)
                        }
                    }
                }
            }
        }
    }

    override fun getItemCount(): Int = items.size

    // Add this helper method for showing full screen images
    private fun showFullScreenImage(context: Context, imageUrl: String) {
        val intent = Intent(context, ActivityImageViewer::class.java).apply {
            putExtra("IMAGE_URL", imageUrl)
        }
        context.startActivity(intent)
    }

    inner class ChatSendViewHolder(private val binding: ItemSendChatBinding) :
        RecyclerView.ViewHolder(binding.root) {

        fun bind(chat: ChatMessage) {
            with(binding) {
                textViewName.text = chat.senderName
                textViewTeam.text = chat.team
                textViewMessage.text = chat.message

                // Handle image content
                if (chat.imageUrl.isNotEmpty()) {
                    imageViewContent.visibility = View.VISIBLE
                    // Load image with Glide
                    Glide.with(itemView.context)
                        .load(chat.imageUrl)
                        .into(imageViewContent)

                    // Make image clickable for full screen view
                    imageViewContent.setOnClickListener {
                        showFullScreenImage(itemView.context, chat.imageUrl)
                    }
                } else {
                    imageViewContent.visibility = View.GONE
                }

                // Load profile picture
                loadProfilePicture(chat.senderId, binding.imageViewProfile)

                // Load team logo
                loadTeamLogo(chat.team, binding.imageViewTeam)

                // Set reaction values
                updateReactions(chat)

                // Set hit/miss counts
                updateHitMiss(chat)

                // Set comment count
                updateComments(chat)

                // Set reaction click listeners without reloading
                tvAngryEmoji.setOnClickListener { addReaction(chat, "fire", adapterPosition) }
                tvHappyEmoji.setOnClickListener { addReaction(chat, "laugh", adapterPosition) }
                tvCryingEmoji.setOnClickListener { addReaction(chat, "cry", adapterPosition) }
                tvSadEmoji.setOnClickListener { addReaction(chat, "troll", adapterPosition) }

                // Set hit/miss click listeners
                buttonHit.setOnClickListener { updateHitOrMiss(chat, "hit", adapterPosition) }
                buttonMiss.setOnClickListener { updateHitOrMiss(chat, "miss", adapterPosition) }

                textViewComments.setOnClickListener {
                    val context = itemView.context
                    val intent = Intent(context, CommentActivity::class.java).apply {
                        putExtra("MESSAGE_ID", chat.id)
                        putExtra("MESSAGE_TYPE", "chat")
                    }
                    context.startActivity(intent)
                }
            }
        }

        fun updateReactions(chat: ChatMessage) {
            binding.tvAngryEmoji.text = "🤬 ${chat.reactions["fire"] ?: 0}"
            binding.tvHappyEmoji.text = "😁 ${chat.reactions["laugh"] ?: 0}"
            binding.tvCryingEmoji.text = "😭 ${chat.reactions["cry"] ?: 0}"
            binding.tvSadEmoji.text = "💔 ${chat.reactions["troll"] ?: 0}"
        }

        fun updateHitMiss(chat: ChatMessage) {
            binding.buttonHit.text = "🔥 ${chat.hit}"
            binding.buttonMiss.text = "❌ ${chat.miss}"
        }

        fun updateComments(chat: ChatMessage) {
            // First check if commentCount is greater than 0, use that if available
            val count = if (chat.commentCount > 0) chat.commentCount else chat.comments.size
            binding.textViewComments.text = "View Comments ($count)"
        }
    }

    inner class ChatReceiveViewHolder(private val binding: ItemReceiveChatBinding) :
        RecyclerView.ViewHolder(binding.root) {

        fun bind(chat: ChatMessage) {
            with(binding) {
                textViewName.text = chat.senderName
                textViewTeam.text = chat.team
                textViewMessage.text = chat.message

                // Handle image content
                if (chat.imageUrl.isNotEmpty()) {
                    imageViewContent.visibility = View.VISIBLE
                    // Load image with Glide
                    Glide.with(itemView.context)
                        .load(chat.imageUrl)
                        .into(imageViewContent)

                    // Make image clickable for full screen view
                    imageViewContent.setOnClickListener {
                        showFullScreenImage(itemView.context, chat.imageUrl)
                    }
                } else {
                    imageViewContent.visibility = View.GONE
                }

                // Load profile picture
                loadProfilePicture(chat.senderId, binding.imageViewProfile)

                // Load team logo
                loadTeamLogo(chat.team, binding.imageViewTeam)

                // Set reaction values
                updateReactions(chat)

                // Set hit/miss counts
                updateHitMiss(chat)

                // Set comment count
                updateComments(chat)

                // Set reaction click listeners
                tvAngryEmoji.setOnClickListener { addReaction(chat, "fire", adapterPosition) }
                tvHappyEmoji.setOnClickListener { addReaction(chat, "laugh", adapterPosition) }
                tvCryingEmoji.setOnClickListener { addReaction(chat, "cry", adapterPosition) }
                tvSadEmoji.setOnClickListener { addReaction(chat, "troll", adapterPosition) }

                // Set hit/miss click listeners
                buttonHit.setOnClickListener { updateHitOrMiss(chat, "hit", adapterPosition) }
                buttonMiss.setOnClickListener { updateHitOrMiss(chat, "miss", adapterPosition) }

                textViewComments.setOnClickListener {
                    val context = itemView.context
                    val intent = Intent(context, CommentActivity::class.java).apply {
                        putExtra("MESSAGE_ID", chat.id)
                        putExtra("MESSAGE_TYPE", "chat")
                    }
                    context.startActivity(intent)
                }
            }
        }

        fun updateReactions(chat: ChatMessage) {
            binding.tvAngryEmoji.text = "🤬 ${chat.reactions["fire"] ?: 0}"
            binding.tvHappyEmoji.text = "😁 ${chat.reactions["laugh"] ?: 0}"
            binding.tvCryingEmoji.text = "😭 ${chat.reactions["cry"] ?: 0}"
            binding.tvSadEmoji.text = "💔 ${chat.reactions["troll"] ?: 0}"
        }

        fun updateHitMiss(chat: ChatMessage) {
            binding.buttonHit.text = "🔥 ${chat.hit}"
            binding.buttonMiss.text = "❌ ${chat.miss}"
        }

        fun updateComments(chat: ChatMessage) {
            val count = if (chat.commentCount > 0) chat.commentCount else chat.comments.size
            binding.textViewComments.text = "View Comments ($count)"
        }
    }

    inner class PollViewHolder(private val binding: ItemPollMessageBinding) :
        RecyclerView.ViewHolder(binding.root) {

        // Keep track of views for direct updates
        private val optionViews = HashMap<String, View>()
        private val radioButtons = HashMap<String, RadioButton>()
        private val textPercentages = HashMap<String, TextView>()
        private val progressBars = HashMap<String, ProgressBar>()
        private val textOptions = HashMap<String, TextView>()

        fun bind(poll: PollMessage) {
            with(binding) {
                textViewName.text = poll.senderName
                textViewTeam.text = poll.team
                textViewMessage.text = poll.question

                // Load profile picture
                loadProfilePicture(poll.senderId, binding.imageViewProfile)

                // Load team logo
                loadTeamLogo(poll.team, binding.imageViewTeam)

                // Set reaction values
                updateReactions(poll)

                // Set hit/miss counts
                updateHitMiss(poll)

                // Set comment count
                updateComments(poll)

                // Set up poll options
                setupPollOptions(poll)

                // Set reaction click listeners
                tvAngryEmoji.setOnClickListener { addReaction(poll, "fire", adapterPosition) }
                tvHappyEmoji.setOnClickListener { addReaction(poll, "laugh", adapterPosition) }
                tvCryingEmoji.setOnClickListener { addReaction(poll, "cry", adapterPosition) }
                tvSadEmoji.setOnClickListener { addReaction(poll, "troll", adapterPosition) }

                // Set hit/miss click listeners
                buttonHit.setOnClickListener { updateHitOrMiss(poll, "hit", adapterPosition) }
                buttonMiss.setOnClickListener { updateHitOrMiss(poll, "miss", adapterPosition) }

                textViewComments.setOnClickListener {
                    val context = itemView.context
                    val intent = Intent(context, CommentActivity::class.java).apply {
                        putExtra("MESSAGE_ID", poll.id)
                        putExtra("MESSAGE_TYPE", "poll")
                    }
                    context.startActivity(intent)
                }
            }
        }

        fun updateReactions(poll: PollMessage) {
            binding.tvAngryEmoji.text = "🤬 ${poll.reactions["fire"] ?: 0}"
            binding.tvHappyEmoji.text = "😁 ${poll.reactions["laugh"] ?: 0}"
            binding.tvCryingEmoji.text = "😭 ${poll.reactions["cry"] ?: 0}"
            binding.tvSadEmoji.text = "💔 ${poll.reactions["troll"] ?: 0}"
        }

        fun updateHitMiss(poll: PollMessage) {
            binding.buttonHit.text = "🔥 ${poll.hit}"
            binding.buttonMiss.text = "❌ ${poll.miss}"
        }

        fun updateComments(chat: PollMessage) {
            val count = if (chat.commentCount > 0) chat.commentCount else chat.comments.size
            binding.textViewComments.text = "View Comments ($count)"
        }

        fun setupPollOptions(poll: PollMessage) {
            val context = itemView.context
            val layoutInflater = LayoutInflater.from(context)
            val currentUser = FirebaseAuth.getInstance().currentUser

            // Clear previous options and cache
            binding.linearLayoutOptions.removeAllViews()
            optionViews.clear()
            radioButtons.clear()
            textPercentages.clear()
            progressBars.clear()
            textOptions.clear()

            // Calculate total votes
            val totalVotes = poll.options.values.sum()

            // Check if current user has voted
            val currentUserVote = if (currentUser != null && poll.voters != null) {
                poll.voters!![currentUser.uid]
            } else null

            // Add options
            for ((option, votes) in poll.options) {
                val optionView = layoutInflater.inflate(R.layout.item_poll_option, binding.linearLayoutOptions, false)
                val radioButton = optionView.findViewById<RadioButton>(R.id.radioButtonOption)
                val textOption = optionView.findViewById<TextView>(R.id.textViewOption)
                val textPercentage = optionView.findViewById<TextView>(R.id.textViewPercentage)
                val progressBar = optionView.findViewById<ProgressBar>(R.id.progressBarOption)

                // Cache views for direct access
                optionViews[option] = optionView
                radioButtons[option] = radioButton
                textPercentages[option] = textPercentage
                progressBars[option] = progressBar
                textOptions[option] = textOption

                // Calculate percentage
                val percentage = if (totalVotes > 0) (votes * 100 / totalVotes) else 0

                // Set views
                radioButton.text = ""  // Clear default text
                textOption.text = option
                textPercentage.text = "$percentage%"

                // Check if this is the user's selection
                val isUserChoice = option == currentUserVote
                radioButton.isChecked = isUserChoice

                // Style the selected option differently
                if (isUserChoice) {
                    textOption.setTextColor(ContextCompat.getColor(context, R.color.grey))
                    textOption.setTypeface(null, Typeface.BOLD)
                } else {
                    textOption.setTextColor(ContextCompat.getColor(context, R.color.white))
                    textOption.setTypeface(null, Typeface.NORMAL)
                }

                // Set up progress bar
                progressBar.isIndeterminate = false
                progressBar.max = 100
                progressBar.progress = percentage

                // Store option as tag
                optionView.tag = option

                // Set click listener for the whole row
                optionView.setOnClickListener {
                    if (currentUser != null) {
                        // Only process the vote if this isn't already the user's selection
                        if (option != currentUserVote) {
                            // Use direct transaction like hit/miss buttons
                            processPollVote(poll, option, currentUser.uid)
                        }
                    } else {
                        Toast.makeText(context, "Please log in to vote", Toast.LENGTH_SHORT).show()
                    }
                }

                binding.linearLayoutOptions.addView(optionView)
            }
        }

        private fun processPollVote(poll: PollMessage, selectedOption: String, userId: String) {
            // Disable all options while processing
            toggleOptionsEnabled(false)

            // Get reference to the poll in Firebase
            val pollRef = FirebaseDatabase.getInstance().getReference("NoBallZone/polls/${poll.id}")

            // Make a transaction for the entire poll document - this is the key change
            pollRef.runTransaction(object : Transaction.Handler {
                override fun doTransaction(mutableData: MutableData): Transaction.Result {
                    // Get the current poll data
                    val pollData = mutableData.getValue(PollMessage::class.java) ?: return Transaction.success(mutableData)

                    // Get current voter data
                    val voters = pollData.voters ?: mutableMapOf()
                    val previousVote = voters[userId]

                    // Update votes
                    val options = pollData.options.toMutableMap()

                    // If previously voted for a different option, decrement that count
                    if (previousVote != null && previousVote != selectedOption) {
                        val prevCount = options[previousVote] ?: 0
                        if (prevCount > 0) {
                            options[previousVote] = prevCount - 1
                        }
                    }

                    // Increment the selected option count
                    val newCount = (options[selectedOption] ?: 0) + 1
                    options[selectedOption] = newCount

                    // Record the user's vote
                    voters[userId] = selectedOption

                    // Update the poll data
                    pollData.options = options
                    pollData.voters = voters

                    // Set the data back to Firebase
                    mutableData.value = pollData

                    return Transaction.success(mutableData)
                }

                override fun onComplete(error: DatabaseError?, committed: Boolean, dataSnapshot: DataSnapshot?) {
                    // Re-enable options
                    toggleOptionsEnabled(true)

                    if (error != null) {
                        Log.e("PollVoting", "Transaction failed: ${error.message}")
                        Toast.makeText(itemView.context, "Failed to vote: ${error.message}", Toast.LENGTH_SHORT).show()
                        return
                    }

                    if (!committed) {
                        Log.e("PollVoting", "Transaction not committed")
                        Toast.makeText(itemView.context, "Vote not recorded, please try again", Toast.LENGTH_SHORT).show()
                        return
                    }

                    // Transaction successful, update UI with the new data
                    val updatedPoll = dataSnapshot?.getValue(PollMessage::class.java)
                    if (updatedPoll != null && adapterPosition != RecyclerView.NO_POSITION) {
                        // Update the poll in the items list
                        if (items[adapterPosition] is PollMessage) {
                            // Create a copy of the updated poll
                            val updatedPollInList = items[adapterPosition] as PollMessage
                            updatedPollInList.options = updatedPoll.options
                            updatedPollInList.voters = updatedPoll.voters

                            // Update UI with animations
                            updatePollUI(updatedPollInList)
                        }
                    }
                }
            })
        }

        private fun updatePollUI(poll: PollMessage) {
            val totalVotes = poll.options.values.sum()
            val currentUser = FirebaseAuth.getInstance().currentUser
            val currentUserVote = if (currentUser != null && poll.voters != null) {
                poll.voters!![currentUser.uid]
            } else null

            // Reset all radio buttons
            for ((_, radioButton) in radioButtons) {
                radioButton.isChecked = false
            }

            // Update each option
            for ((option, votes) in poll.options) {
                val percentage = if (totalVotes > 0) (votes * 100 / totalVotes) else 0

                // Update percentage text
                textPercentages[option]?.text = "$percentage%"

                // Update progress bar with animation
                progressBars[option]?.let { progressBar ->
                    val animator = ObjectAnimator.ofInt(progressBar, "progress", progressBar.progress, percentage)
                    animator.duration = 300
                    animator.interpolator = DecelerateInterpolator()
                    animator.start()
                }

                // Check if this is the user's selection
                val isUserChoice = option == currentUserVote

                // Update radio button
                radioButtons[option]?.isChecked = isUserChoice

                // Update text styling
                textOptions[option]?.let { textOption ->
                    if (isUserChoice) {
                        textOption.setTextColor(ContextCompat.getColor(itemView.context, R.color.grey))
                        textOption.setTypeface(null, Typeface.BOLD)
                    } else {
                        textOption.setTextColor(ContextCompat.getColor(itemView.context, R.color.white))
                        textOption.setTypeface(null, Typeface.NORMAL)
                    }
                }
            }
        }

        private fun toggleOptionsEnabled(enabled: Boolean) {
            // Enable/disable all option views
            for (i in 0 until binding.linearLayoutOptions.childCount) {
                binding.linearLayoutOptions.getChildAt(i).isEnabled = enabled
            }
        }
    }

    // Utility method to update a reaction (without reloading)
    // Utility method to update a reaction (fixed to prevent double counting)
    private fun addReaction(message: Any, reactionType: String, position: Int) {
        if (position == RecyclerView.NO_POSITION) return

        val messageId: String
        val dbPath: String

        when (message) {
            is ChatMessage -> {
                messageId = message.id
                dbPath = "NoBallZone/chats"
            }
            is PollMessage -> {
                messageId = message.id
                dbPath = "NoBallZone/polls"
            }
            else -> return
        }

        val reactionRef = FirebaseDatabase.getInstance()
            .getReference("$dbPath/$messageId/reactions/$reactionType")

        reactionRef.runTransaction(object : Transaction.Handler {
            override fun doTransaction(currentData: MutableData): Transaction.Result {
                val currentValue = currentData.getValue(Int::class.java) ?: 0
                currentData.value = currentValue + 1
                return Transaction.success(currentData)
            }

            override fun onComplete(error: DatabaseError?, committed: Boolean, currentData: DataSnapshot?) {
                if (committed && error == null && currentData != null) {
                    // Only update the local model with the value from Firebase
                    // This prevents any possibility of double counting
                    val newValue = currentData.getValue(Int::class.java) ?: 0

                    when (message) {
                        is ChatMessage -> {
                            message.reactions[reactionType] = newValue
                            notifyItemChanged(position, PAYLOAD_REACTION)
                        }
                        is PollMessage -> {
                            message.reactions[reactionType] = newValue
                            notifyItemChanged(position, PAYLOAD_REACTION)
                        }
                    }
                }
            }
        })
    }

    // Utility method to update hit or miss counts (fixed to prevent double counting)
    private fun updateHitOrMiss(message: Any, type: String, position: Int) {
        if (position == RecyclerView.NO_POSITION) return

        val messageId: String
        val dbPath: String

        when (message) {
            is ChatMessage -> {
                messageId = message.id
                dbPath = "NoBallZone/chats"
            }
            is PollMessage -> {
                messageId = message.id
                dbPath = "NoBallZone/polls"
            }
            else -> return
        }

        val hitMissRef = FirebaseDatabase.getInstance().getReference("$dbPath/$messageId/$type")

        hitMissRef.runTransaction(object : Transaction.Handler {
            override fun doTransaction(currentData: MutableData): Transaction.Result {
                val currentValue = currentData.getValue(Int::class.java) ?: 0
                currentData.value = currentValue + 1
                return Transaction.success(currentData)
            }

            override fun onComplete(error: DatabaseError?, committed: Boolean, currentData: DataSnapshot?) {
                if (committed && error == null && currentData != null) {
                    // Only update local model with the value from Firebase
                    val newValue = currentData.getValue(Int::class.java) ?: 0

                    when (message) {
                        is ChatMessage -> {
                            if (type == "hit") message.hit = newValue else message.miss = newValue
                            notifyItemChanged(position, PAYLOAD_HIT_MISS)
                        }
                        is PollMessage -> {
                            if (type == "hit") message.hit = newValue else message.miss = newValue
                            notifyItemChanged(position, PAYLOAD_HIT_MISS)
                        }
                    }
                }
            }
        })
    }

    // Common utility methods
    private fun loadProfilePicture(userId: String, imageView: ImageView) {
        val userRef = FirebaseDatabase.getInstance().getReference("Users/$userId/profilePhoto")
        userRef.addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val profileUrl = snapshot.getValue(String::class.java)
                if (profileUrl != null) {
                    Glide.with(imageView.context)
                        .load(profileUrl)
                        .placeholder(R.drawable.profile_icon)
                        .error(R.drawable.profile_icon)
                        .circleCrop()
                        .into(imageView)
                } else {
                    imageView.setImageResource(R.drawable.profile_icon)
                }
            }

            override fun onCancelled(error: DatabaseError) {
                imageView.setImageResource(R.drawable.profile_icon)
            }
        })
    }

    private fun loadTeamLogo(teamName: String, imageView: ImageView) {
        val teamLogoMap = mapOf(
            "CSK" to R.drawable.csk,
            "MI" to R.drawable.mi,
            "RCB" to R.drawable.rcb,
            "KKR" to R.drawable.kkr,
            "DC" to R.drawable.dc,
            "SRH" to R.drawable.sh,
            "PBKS" to R.drawable.pk,
            "RR" to R.drawable.rr,
            "GT" to R.drawable.gt,
            "LSG" to R.drawable.lsg
        )
        val logoResource = teamLogoMap[teamName] ?: R.drawable.icc_logo
        imageView.setImageResource(logoResource)
    }
}